<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/Daotin/fe-interview-2024</id><title>RSS feed of Daotin's fe-interview-2024</title><updated>2024-08-16T07:20:16.750348+00:00</updated><link href="https://github.com/Daotin/fe-interview-2024"/><link href="https://raw.githubusercontent.com/Daotin/fe-interview-2024/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/Daotin/fe-interview-2024/issues/5</id><title>typeof和instanceof的区别</title><updated>2024-08-16T07:20:16.935118+00:00</updated><content type="html"><![CDATA[<p><code>typeof</code> 和 <code>instanceof</code> 都是 JavaScript 中用于类型检查的操作符，但它们的使用场景和功能有所不同。</p>
<p><code>typeof</code> 用于检测一个变量的数据类型。它返回一个字符串，表示变量的类型，比如 <code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;undefined&quot;</code>、<code>&quot;object&quot;</code>、<code>&quot;function&quot;</code>、以及 ES6 引入的 <code>&quot;symbol&quot;</code>。<code>typeof</code> 适用于基本数据类型的判断，尤其是当你不确定变量是否已定义或是否为基本类型时。此外，对于引用类型的对象，<code>typeof</code> 通常返回 <code>&quot;object&quot;</code>，但需要注意的是，对 <code>null</code> 执行 <code>typeof</code> 也会返回 <code>&quot;object&quot;</code>，这是一种历史遗留的设计问题。</p>
<blockquote>
<p>[!warning]
其中数组、对象、null都会被判断为object，其他判断都正确。</p>
</blockquote>
<p>相比之下，<code>instanceof</code> 用于检测一个对象是否为某个构造函数的实例。它通过检查对象的原型链来判断，返回一个布尔值。<code>instanceof</code> 主要应用于判断复杂类型，比如自定义类实例或数组等。它能够更准确地识别出对象的具体类型，尤其是在需要区分对象的继承关系或具体类型时。</p>
<p>总结来说，<code>typeof</code> 适合用于判断基本数据类型，而 <code>instanceof</code> 则适用于检测对象是否属于特定的类或构造函数。两者结合使用，可以在不同场景下进行灵活的类型检查。</p>
]]></content><link href="https://github.com/Daotin/fe-interview-2024/issues/5"/><category term="javascript"/><published>2024-08-16T07:19:51+00:00</published></entry><entry><id>https://github.com/Daotin/fe-interview-2024/issues/4</id><title>水平垂直居中的方案</title><updated>2024-08-16T07:20:17.040601+00:00</updated><content type="html"><![CDATA[<p>1、有固定的宽度
方法1：absolute + 负margin
方法2：absolute + margin: auto</p>
<p>2、无固定的宽度
方法1：absolute + transform反向偏移
方法2：flex布局</p>
<p><a href="https://daotin.github.io/fe-blog/posts/2021/07/27/%E5%9D%97%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html">https://daotin.github.io/fe-blog/posts/2021/07/27/%E5%9D%97%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html</a></p>
]]></content><link href="https://github.com/Daotin/fe-interview-2024/issues/4"/><category term="css"/><published>2024-08-16T06:32:26+00:00</published></entry><entry><id>https://github.com/Daotin/fe-interview-2024/issues/3</id><title>CSS几种定位的规则、定位参照物、对文档流的影响</title><updated>2024-08-16T07:20:17.120312+00:00</updated><content type="html"><![CDATA[<ol>
<li>
<p><strong>静态定位 (<code>static</code>)</strong>：</p>
<ul>
<li><strong>规则</strong>：默认定位，元素按文档流正常排列。</li>
<li><strong>定位参照物</strong>：无。</li>
<li><strong>对文档流影响</strong>：不影响，元素保持在文档流中。</li>
<li><strong>应用场景</strong>：默认使用，适合大部分情况。</li>
</ul>
</li>
<li>
<p><strong>相对定位 (<code>relative</code>)</strong>：</p>
<ul>
<li><strong>规则</strong>：相对于元素自身的原始位置进行偏移。</li>
<li><strong>定位参照物</strong>：元素自身的位置。</li>
<li><strong>对文档流影响</strong>：占据原位置，不脱离文档流。具体来说，当你使用 position: relative 时，该元素会保持在文档流中的原始位置，但你可以使用 left、right、top 和 bottom 属性来调整该元素相对于其原始位置的偏移量。元素仍然会占据其在文档流中的原始位置，只是视觉上会移动。所以，可能导致覆盖到其他元素。</li>
<li><strong>应用场景</strong>：对元素做微调，保持其在文档流中的位置。</li>
</ul>
</li>
<li>
<p><strong>绝对定位 (<code>absolute</code>)</strong>：</p>
<ul>
<li><strong>规则</strong>：相对于最近的已定位祖先元素（<code>relative</code>、<code>absolute</code>或<code>fixed</code>）进行定位；若无，则相对于<code>&lt;html&gt;</code>定位。</li>
<li><strong>定位参照物</strong>：最近的已定位祖先元素或<code>&lt;html&gt;</code>。</li>
<li><strong>对文档流影响</strong>：脱离文档流，不占据空间。</li>
<li><strong>应用场景</strong>：需要精确控制元素位置的场景，如浮动面板或弹出框。</li>
</ul>
</li>
<li>
<p><strong>固定定位 (<code>fixed</code>)</strong>：</p>
<ul>
<li><strong>规则</strong>：相对于浏览器窗口进行定位。</li>
<li><strong>定位参照物</strong>：浏览器窗口。</li>
<li><strong>对文档流影响</strong>：脱离文档流，不占据空间。</li>
<li><strong>应用场景</strong>：固定在页面某个位置不随滚动条滚动，如固定导航栏。</li>
</ul>
</li>
<li>
<p><strong>粘性定位 (<code>sticky</code>)</strong>：</p>
<ul>
<li><strong>规则</strong>：元素在跨越某个阈值前表现为相对定位，超出阈值后表现为固定定位。比如，top: 10px 是相对于视口顶部的偏移量，而不是相对于其父元素或其他元素。当元素达到这个偏移位置时，它就会“粘”在那个位置。</li>
<li><strong>定位参照物</strong>：最近的滚动容器（通常是<code>&lt;html&gt;</code>）。</li>
<li><strong>对文档流影响</strong>：占据空间，但在特定条件下会脱离文档流。</li>
<li><strong>应用场景</strong>：如表头随滚动固定在顶部的效果。</li>
</ul>
</li>
</ol>
]]></content><link href="https://github.com/Daotin/fe-interview-2024/issues/3"/><category term="css"/><published>2024-08-16T06:21:23+00:00</published></entry><entry><id>https://github.com/Daotin/fe-interview-2024/issues/2</id><title>script、script async 和 script defer 的区别</title><updated>2024-08-16T07:20:17.204351+00:00</updated><content type="html"><![CDATA[<ol>
<li>
<p><strong><code>script</code></strong>: </p>
<ul>
<li>默认情况下同步执行，会阻塞页面解析。</li>
<li><strong>应用场景</strong>：一般用于必须在页面加载前执行的脚本，如动态内容生成。</li>
</ul>
</li>
<li>
<p><strong><code>script async</code></strong>: </p>
<ul>
<li>异步执行，脚本下载完成后立即执行，不会阻塞页面解析。</li>
<li><strong>应用场景</strong>：适用于独立于其他脚本或DOM的脚本，如广告或统计脚本。</li>
</ul>
</li>
<li>
<p><strong><code>script defer</code></strong>: </p>
<ul>
<li>异步执行，但会在HTML解析完成后、<code>DOMContentLoaded</code>事件前按顺序执行。</li>
<li><strong>应用场景</strong>：用于需要在DOM解析完后执行的脚本，如初始化脚本。</li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li><code>async</code>和<code>defer</code>只对外部脚本有效，内联脚本无效。</li>
<li>使用<code>defer</code>时，确保脚本间的执行顺序。</li>
</ul>
]]></content><link href="https://github.com/Daotin/fe-interview-2024/issues/2"/><category term="html"/><published>2024-08-16T05:52:24+00:00</published></entry><entry><id>https://github.com/Daotin/fe-interview-2024/issues/1</id><title>demo</title><updated>2024-08-16T07:20:17.295822+00:00</updated><content type="html"><![CDATA[<p>demodemo</p>
]]></content><link href="https://github.com/Daotin/fe-interview-2024/issues/1"/><category term="demo"/><published>2024-08-16T02:37:19+00:00</published></entry></feed>